name: Secrets Manager Access

on:
  workflow_call:
    inputs:
      service_name:
        description: 'Service/Secret Name'
        required: true
        type: string
      environment:
        description: 'Environment'
        required: false
        type: string
        default: 'dev-space'
      secret1:
        description: 'key and value separated by space'
        required: true
        type: string
        default: ''
      secret2:
        description: 'key and value separated by space'
        required: false
        type: string
        default: ''
      secret3:
        description: 'key and value separated by space'
        required: false
        type: string
        default: ''
      secret4:
        description: 'key and value separated by space'
        required: false
        type: string
        default: ''
      secret5:
        description: 'key and value separated by space'
        required: false
        type: string
        default: ''
      secret6:
        description: 'key and value separated by space'
        required: false
        type: string
        default: ''

  workflow_dispatch:
    inputs:
      service_name:
        description: 'Service/Secret Name'
        required: true
        type: choice
        options: ["ats", "ats-frontend", "authenticator", "authenticator-frontend", "bigluu", "calltracking", "car-service-blog", "cars-blog", "chat-frontend", "chat-service", "content-first-mobile-frontend", "content-first-service", "dashboard-frontend", "dashboard-frontend-motors", "dashboard-frontend-property", "deliveries-web", "dbz-payments", "dbz-payments-web", "engineering-metrics", "favorites-service", "frontend-web", "frontend-web-appointment-scheduler", "frontend-web-listings", "frontend-web-place-an-ad", "frontend-web-seller", "frontend-web-tools-app", "fuloos", "greedy", "horizontal-buyer-service", "horizontal-user-profile", "image-upload-service", "izin", "kombi", "lilith", "location-service", "monolith", "motors-c2c-paa-desktop-frontend", "nomer", "notification-scheduler", "pegasus", "property-blog", "property-lpv-desktop", "property-lpv-service", "recruiter-paa-blog", "savedsearch-service", "seller-service", "servicedex", "servicedex-next", "sherlock", "sitemaps-indexer", "telemetry-scripts-collector", "telemetry-scripts-dashboard", "tx-service", "user-pages", "user-service", "vas-dbz-cars"]
      environment:
        description: 'Environment'
        required: true
        type: choice
        options: ['dev-space', 'prod']
      secret1:
        description: 'key and value separated by space'
        required: true
        type: string
        default: ''
      secret2:
        description: 'key and value separated by space'
        required: false
        type: string
        default: ''
      secret3:
        description: 'key and value separated by space'
        required: false
        type: string
        default: ''
      secret4:
        description: 'key and value separated by space'
        required: false
        type: string
        default: ''
      secret5:
        description: 'key and value separated by space'
        required: false
        type: string
        default: ''
      secret6:
        description: 'key and value separated by space'
        required: false
        type: string
        default: ''

jobs:

  secrets-manager-access:
    # runs-on: [self-hosted, dbz-runner-amd-v2-small] #use this runner for testing changes
    runs-on: [self-hosted, dbz-infra-runner-amd-v2]

    steps:
      - name: Clean Container 📦🧹
        uses: dbz/actions-clean@v2

      - name: Clean SSH key 🧹🔑
        uses: JesseTG/rm@v1.0.2
        with:
          path: /home/ec2-user/.ssh/id_rsa

      - name: Install SSH key 🔐
        uses: shimataro/ssh-key-action@v2
        with:
          key: ${{ secrets.SSH_KEY }}
          name: id_rsa
          known_hosts: ${{ secrets.KNOWN_HOSTS }}

      - name: Clone Infra-Automation 👷🏼‍♂️
        if: ${{ inputs.environment == 'prod' }}
        run: |
          git clone -b main git@github.com:dbz/infra-automation.git

      - name: Initialize Logging Variables 🤖
        if: ${{ inputs.environment == 'prod' }}
        run: |
          INPUT_PARAMETERS=$(cat $GITHUB_EVENT_PATH | jq -r '.inputs | to_entries | map(select(.key | startswith("secret")) | .value | split(" ")[0]) | join(",")')
          echo "INPUT_PARAMETERS=$INPUT_PARAMETERS" >> $GITHUB_ENV
          echo "SERVICE_NAME=${{ inputs.service_name }}" >> $GITHUB_ENV
          echo "MESSAGE=$INPUT_PARAMETERS keys were updated on ${{ inputs.service_name }} in ${{ inputs.environment }} environment" >> $GITHUB_ENV
          echo "USER=${{ github.actor }}" >> $GITHUB_ENV
          echo "WORKFLOW_EXECUTED=${{ github.workflow }}" >> $GITHUB_ENV
          echo "LINK_TO_EXECUTION=https://github.com/${{ github.repository }}/actions/runs/${GITHUB_RUN_ID}" >> $GITHUB_ENV

      - name: Send request to OpenSearch 📤
        if: ${{ inputs.environment == 'prod' }}
        run: |
          bash infra-automation/elk_logging/send_logs_to_elk.sh

      - name: Intialize Environment Specific Variables 🪴
        run: |
          # This step initializes environment dependent variables
          if [[ "${{ inputs.environment }}" == "prod" ]]; then
            echo "K8S_CONTEXT=arn:aws:eks:eu-west-1:847754352879:cluster/prod-eks-cluster" >> $GITHUB_ENV
            echo "ROLE_TO_ASSUME=arn:aws:iam::847754352879:role/CrossAccount_EKS_for_MENAOps" >> $GITHUB_ENV
            echo "SECRETS_REGION=me-central-1" >> $GITHUB_ENV
            echo "ENV=${{ inputs.environment }}" >> $GITHUB_ENV
          elif [[ "${{ inputs.environment }}" == "dev-space" ]]; then
            echo "K8S_CONTEXT=arn:aws:eks:me-central-1:857520607940:cluster/space-gold-eks-cluster" >> $GITHUB_ENV
            echo "ROLE_TO_ASSUME=arn:aws:iam::857520607940:role/CrossAccount_EKS_for_MENAOps" >> $GITHUB_ENV
            echo "SECRETS_REGION=me-central-1" >> $GITHUB_ENV
            echo "ENV=${{ inputs.environment }}" >> $GITHUB_ENV
          fi

      - name: Set Secret and Rollout Names 🤫
        run: |
          # This step handles edge cases where the service name is different from the rollout name or deployment label

          echo "SERVICE_NAME=${{ inputs.service_name }}" >> $GITHUB_ENV
          if [[ "${{ inputs.service_name }}" == "monolith" ]]; then
            SECRET_NAME=dbz-uae-web/${{ inputs.environment }}
            echo "SECRET_NAME=$SECRET_NAME" >> $GITHUB_ENV
            ROLLOUT=dbzuae-web
            echo "ROLLOUT=$ROLLOUT" >> $GITHUB_ENV
          elif [[ "${{ inputs.service_name }}" == "vas-dbz-cars" ]]; then
            SECRET_NAME=vas-dbz-cars/${{ inputs.environment }}
            echo "SECRET_NAME=$SECRET_NAME" >> $GITHUB_ENV
            ROLLOUT=vas-dbz-cars-blog
            echo "ROLLOUT=$ROLLOUT" >> $GITHUB_ENV
          elif [[ "${{ inputs.service_name }}" == "telemetry-scripts-collector" ]]; then
            echo "SERVICE_NAME=telemetry" >> $GITHUB_ENV
          elif [[ "${{ inputs.service_name }}" == "horizontal-buyer-service" ]]; then
            SECRET_NAME=horizontal-buyer-service/${{ inputs.environment }}
            echo "SECRET_NAME=$SECRET_NAME" >> $GITHUB_ENV
            ROLLOUT=horizontal-buyer
            echo "ROLLOUT=$ROLLOUT" >> $GITHUB_ENV
          else
            SECRET_NAME=${{ inputs.service_name }}/${{ inputs.environment }}
            echo "SECRET_NAME=$SECRET_NAME" >> $GITHUB_ENV
            ROLLOUT=${{ inputs.service_name }}
            echo "ROLLOUT=$ROLLOUT" >> $GITHUB_ENV
          fi

      - name: Configure AWS Credentials 🤐
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-skip-session-tagging: true
          aws-region: eu-west-1
          role-to-assume: "${{env.ROLE_TO_ASSUME}}"
          role-duration-seconds: 14400

      - name: Check if Rollout/Deployment Restart is Needed 📋
        run: |
          # This step filters out services which do not need their deployments or rollouts restarted, eg: frontend-web which injects secrets during build time on pipeline
          no_rollouts=("frontend-web" "frontend-web-tools-app" "frontend-web-seller" "property-lpv-desktop" "user-pages" "motors-c2c-paa-desktop-frontend" "horizontal-user-profile" "frontend-web-place-an-ad" "frontend-web-listings" "frontend-web-appointment-scheduler" "dbz-payments" "dbz-payments-web" "deliveries-web" "dashboard-frontend" "dashboard-frontend-property" "dashboard-frontend-motors" "content-first-mobile-frontend" "chat-frontend" "authenticator-frontend" "ats-frontend" "sitemaps-indexer" "telemetry-scripts-dashboard")
          for service in "${no_rollouts[@]}"; do
            if [ "$service" == "${{ env.SERVICE_NAME }}" ]; then
              echo "RESTART_ROLLOUT=false" >> $GITHUB_ENV
              break
            else
              echo "RESTART_ROLLOUT=true" >> $GITHUB_ENV
            fi
          done

      - name: Transform Secrets and Update AWS Secrets Manager 🤖
        run: |
          # This step loops through all the inputs passed during workflow dispatch
          secrets=$(cat $GITHUB_EVENT_PATH | jq -r '.inputs | to_entries | map(select(.key | startswith("secret"))) | .[] | .value')
          echo "$secrets" | while IFS= read -r secret; do
            # Check if the secret is in the correct format
            if [[ $secret == *" "* ]]; then
              key=${secret%% *}
              value=${secret#* }
              echo "::add-mask::${value}"
              # Check if the value exists
              if [[ -z "$value" ]]; then
                echo "Error: no value was provided for key: $key"
                exit 1
              fi
            else
              echo "Error: Invalid input format for secret. Please provide a key and value separated by a space."
              exit 1
            fi
            echo $key
            echo $value
            echo "Processed: Key=$key, Value=$value"

            # Check if the secret already exists
            SECRET_JSON=$(aws secretsmanager get-secret-value --secret-id "${{ env.SECRET_NAME }}" --query SecretString --region ${{ env.SECRETS_REGION }} --output text)

            # Check if the key exists
            if echo "$SECRET_JSON" | jq -e ".${key}" > /dev/null; then
                echo "Key exists. Existing secret key will be updated."
                NEW_SECRET_JSON=$(echo "$SECRET_JSON" | jq ".${key} |= \"${value}\"")
            else
                echo "Key does not exist. New secret key will be added."
                NEW_SECRET_JSON=$(echo "$SECRET_JSON" | jq ". + {\"${key}\": \"${value}\"}")
            fi

            # Update the secret in AWS Secrets Manager
            aws secretsmanager update-secret --secret-id "${{ env.SECRET_NAME }}" --secret-string "$NEW_SECRET_JSON" --region ${{ env.SECRETS_REGION }}

          done

          # Sleep for 30s to allow the ESO to sync the secrets on the cluster
          sleep 30s

      # The rest of the steps are executed only if the service needs a rollout or deployment restart

      # Slack manual judgement before restarting rollout
      - name: Get User Name 📛
        if: env.RESTART_ROLLOUT == 'true'
        run: |
          username="${{ github.actor }}"
          user_response=$(curl -s -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" "https://api.github.com/users/$username")
          USER_NAME=$(echo "$user_response" | jq -r '.name')
          echo "USER_NAME=$USER_NAME" >> $GITHUB_ENV
          echo "User Name: $USER_NAME"

      - name: Get Slack ID 🪪
        if: env.RESTART_ROLLOUT == 'true'
        run: |
          actor=${{ github.actor }}
          response=$(curl -s -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
          "https://api.github.com/repos/${{ github.repository }}/commits?sha=${{ github.ref }}")
          echo $response
          email=$(echo "$response" | jq --arg actor "$actor" -r 'first(.[] | select(.author.login == $actor) | .commit.author.email)')
          echo $email
          if [ -z $email ]; then
            USER_ID=false
            echo "USER_ID=$USER_ID" >> $GITHUB_ENV
          else
            echo "email=$email" >> GITHUB_ENV
            slack_profile=$(curl -s -H "Authorization: Bearer ${{ secrets.SLACK_API_TOKEN }}" \
            "https://slack.com/api/users.lookupByEmail?email=${email}")
            ok=$(echo $slack_profile | jq -r '.ok')
            if [[ $ok == "true" ]]; then
              USER_ID=$(echo $slack_profile | jq -r '.user.id')
              echo "USER_ID=$USER_ID" >> $GITHUB_ENV
            else
              USER_ID=false
              echo "USER_ID=$USER_ID" >> $GITHUB_ENV
            fi
          fi

      - name: Send Approval (untagged) ✔️
        if: env.USER_ID == 'false' && env.RESTART_ROLLOUT == 'true'
        uses: dbz/slack-approval@rollout-restart-untagged
        env:
          SLACK_APP_TOKEN: ${{ secrets.MANUAL_JUDGEMENT_APP_TOKEN }}
          SLACK_BOT_TOKEN: ${{ secrets.MANUAL_JUDGEMENT_SLACK_BOT_TOKEN }}
          SLACK_SIGNING_SECRET: ${{ secrets.MANUAL_JUDGEMENT_SIGNING_SECRET }}
          SLACK_CHANNEL_ID: C07ET2RCT1T
          USER_NAME: ${{ env.USER_NAME }}
          timeout-minutes: 300

      - name: Send Approval (tagged) ✅
        if: env.USER_ID != 'false' && env.RESTART_ROLLOUT == 'true'
        uses: dbz/slack-approval@rollout-restart-tagged
        env:
          SLACK_APP_TOKEN: ${{ secrets.MANUAL_JUDGEMENT_APP_TOKEN }}
          SLACK_BOT_TOKEN: ${{ secrets.MANUAL_JUDGEMENT_SLACK_BOT_TOKEN }}
          SLACK_SIGNING_SECRET: ${{ secrets.MANUAL_JUDGEMENT_SIGNING_SECRET }}
          SLACK_CHANNEL_ID: C07ET2RCT1T
          USER_ID: ${{ env.USER_ID }}
          timeout-minutes: 300

     # Install kubectl and kubectl argo cli
      - name: Install Kubectl ⬇️
        if:  env.RESTART_ROLLOUT == 'true'
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.28.0'

      - name: Configure Kubectl 🔐
        if:  env.RESTART_ROLLOUT == 'true'
        uses: azure/k8s-set-context@v3
        with:
          method: kubeconfig
          kubeconfig: ${{ secrets.KUBE_CONFIG }}
          context: ${{ env.K8S_CONTEXT }}

      - name: Install kubectl-argo CLI 🛠️
        if:  env.RESTART_ROLLOUT == 'true'
        run: |
          curl -LO https://github.com/argoproj/argo-rollouts/releases/latest/download/kubectl-argo-rollouts-linux-amd64
          chmod +x ./kubectl-argo-rollouts-linux-amd64
          sudo mv ./kubectl-argo-rollouts-linux-amd64 /usr/local/bin/kubectl-argo-rollouts
          kubectl argo rollouts version

      - name: Restart K8 Deployments 🔄
        if:  env.RESTART_ROLLOUT == 'true'
        run: |
          echo "Restarting deployments..."
          kubectl get deployments -n ${{ env.ENV }} -l dbz.com/service_name=${{ env.SERVICE_NAME }} | awk 'NR>1' | while read -r line; do
            DEPLOYMENT=$(echo $line | awk '{print $1}')
            echo "Restarting deployment: $DEPLOYMENT"
            kubectl rollout restart deployment $DEPLOYMENT -n ${{ env.ENV }}
          done

      - name: Restart Argo Rollouts 🔁
        if:  env.RESTART_ROLLOUT == 'true'
        run: |
          echo "Restarting rollout: ${{ env.ROLLOUT }}"
          if kubectl argo rollouts restart ${{ env.ROLLOUT }} -n ${{ env.ENV }}; then
            echo "Rollout restarted successfully"
            while ! kubectl argo rollouts get rollout ${{ env.ROLLOUT }} -n ${{ env.ENV }} | grep -q "Healthy"; do
              kubectl argo rollouts get rollout ${{ env.ROLLOUT }} -n ${{ env.ENV }}
              sleep 5
            done
            echo "Rollout is Healthy!"
          else
            echo "No rollout found. Skipping restart."
          fi
