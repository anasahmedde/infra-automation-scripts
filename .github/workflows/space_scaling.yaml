name: Space Scaling
run-name: Scaling dev-space ${{ inputs.scaling_action }}

on:
  workflow_call:
    inputs:
      scaling_action:
        description: 'Choose the scaling action'
        required: true
        type: string

jobs:

    scaling-job:
        runs-on: [self-hosted, dbz-runner-arm-v2-small]
        steps:

        - name: Clean Container 📦🧹
          uses: dbz/actions-clean@v2

        - name: Set environment variables 🌐
          run: |
            # define scaling action
            scaling_action=${{ inputs.scaling_action }}
            echo "scaling_action=$scaling_action" >> $GITHUB_ENV

            # define environments
            export environment=dev-space
            echo "environment=$environment" >> $GITHUB_ENV

            # define cluster name
            export cluster_name=space-gold-eks-cluster
            echo "cluster_name=$cluster_name" >> $GITHUB_ENV

            # define region
            export region=me-central-1
            echo "region=$region" >> $GITHUB_ENV

        # SLACK NOTIFICATION STEPS
        - name: Get username
          if: github.event_name == 'workflow_dispatch'
          run: |
            username="${{ github.actor }}"
            user_response=$(curl -s -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" "https://api.github.com/users/$username")
            USER_NAME=$(echo "$user_response" | jq -r '.name')
            # Check if USER_NAME is empty or null
            if [ -z "$USER_NAME" ] || [ "$USER_NAME" == "null" ]; then
                USER_NAME="$username"
            fi
            echo "USER_NAME=$USER_NAME" >> $GITHUB_ENV
            echo "User Name: $USER_NAME"

        - name: Get Slack ID
          if: github.event_name == 'workflow_dispatch'
          run: |
            actor=${{ github.actor }}
            response=$(curl -s -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
            "https://api.github.com/repos/${{ github.repository }}/commits?sha=${{ github.ref }}")
            email=$(echo "$response" | jq --arg actor "$actor" -r 'first(.[] | select(.author.login == $actor) | .commit.author.email)')
            echo $email
            if [ -z $email ]; then
                USER_ID=false
                echo "USER_ID=$USER_ID" >> $GITHUB_ENV
            else
                echo "email=$email" >> GITHUB_ENV
                slack_profile=$(curl -s -H "Authorization: Bearer ${{ secrets.SLACK_API_TOKEN }}" \
                "https://slack.com/api/users.lookupByEmail?email=${email}")
                ok=$(echo $slack_profile | jq -r '.ok')
                if [[ $ok == "true" ]]; then
                    USER_ID=$(echo $slack_profile | jq -r '.user.id')
                    echo "USER_ID=$USER_ID" >> $GITHUB_ENV
                else
                    USER_ID=false
                    echo "USER_ID=$USER_ID" >> $GITHUB_ENV
                fi
            fi

        - name: Manual Scaling Slack Notification (tagged)
          uses: slackapi/slack-github-action@v1.25.0
          if: github.event_name == 'workflow_dispatch' && env.USER_ID != 'false'
          continue-on-error: true
          with:
            channel-id: C0232T0LP7V
            slack-message: "💸 *Environment Scaling Notification* - <@${{ env.USER_ID }}> <https://github.com/dbz/infra-automation/actions/runs/${{ github.run_id }}|triggered scale ${{ env.scaling_action }} for> dev-space. Please wait as it will take about 10-15 minutes to completely scale ${{ env.scaling_action }} 🙂"
          env:
            SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_TOKEN }}

        - name: Manual Scaling Slack Notification (untagged)
          uses: slackapi/slack-github-action@v1.25.0
          if: github.event_name == 'workflow_dispatch' && env.USER_ID == 'false'
          continue-on-error: true
          with:
            channel-id: C0232T0LP7V
            slack-message: "💸 *Environment Scaling Notification* - ${{ env.USER_NAME }} <https://github.com/dbz/infra-automation/actions/runs/${{ github.run_id }}|triggered scale ${{ env.scaling_action }} for> dev-space. Please wait as it will take about 10-15 minutes to completely scale ${{ env.scaling_action }} 🙂"
          env:
              SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_TOKEN }}

        - name: Bot Activity Slack Notification
          uses: slackapi/slack-github-action@v1.25.0
          if: github.event_name == 'workflow_call' || github.event_name == 'schedule'
          with:
            channel-id: C0232T0LP7V
            slack-message: "💸 *Environment Scaling Notification* - `Autoscaling` <https://github.com/dbz/infra-automation/actions/runs/${{ github.run_id }}|triggered scale ${{ env.scaling_action }} for> dev-space"
          env:
            SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_TOKEN }}

        # SCALING STEPS BEGIN FROM HERE
        - name: Configure AWS Credentials 💳
          uses: aws-actions/configure-aws-credentials@v1
          with:
            role-to-assume: arn:aws:iam::857520607940:role/CrossAccount_EKS_for_MENAOps
            aws-region: eu-west-1
            role-skip-session-tagging: true
            role-duration-seconds: 3600

        # SCALE ASGs
        - name: Get ASG Name for Space-Gold
          run: |
            # Get the Auto Scaling group name based on the environment name in the tag eks:nodegroup-name
            asg_name=$(aws autoscaling describe-auto-scaling-groups \
            --query "AutoScalingGroups[?Tags[?Key=='eks:nodegroup-name' && contains(Value, 'space-gold')] && Tags[?Key=='eks:cluster-name' && Value=='${{ env.cluster_name }}']].AutoScalingGroupName" \
            --region ${{ env.region }} --output text)
              echo "asg_name=$asg_name" >> $GITHUB_ENV

            # Check if the Auto Scaling group was found
            if [ -z "$asg_name" ]; then
                echo "No Auto Scaling group found with the environment name 'space-gold'."
                curl -X POST -H 'Content-type: application/json' --data "{\"text\":\"An error occured while scaling space-gold as no associated ASG could be found\"}" ${{ secrets.DB_TESTING_SLACK_WEBHOOK }}
                exit 1
            fi

        - name: Scale ASG Up
          if: env.scaling_action == 'up'
          run: |
            # Loop through each ASG and set min, max and desired to 2
            for asg_name in ${{ env.asg_name }}; do
              echo "Scaling ASG: $asg_name"
              aws autoscaling update-auto-scaling-group \
                --auto-scaling-group-name "$asg_name" \
                --min-size 1 \
                --max-size 20 \
                --desired-capacity 1 \
                --region "${{ env.region }}"
              echo "Scaled Auto Scaling group '$asg_name' to min=1, max=5, desired=1."
            done

        - name: Scale ASG Down
          if: env.scaling_action == 'down'
          run: |
            # Loop through each ASG and set min, max and desired to 0
            for asg_name in ${{ env.asg_name }}; do
              echo "Scaling ASG: $asg_name"
              aws autoscaling update-auto-scaling-group \
                --auto-scaling-group-name "$asg_name" \
                --min-size 0 \
                --max-size 0 \
                --desired-capacity 0 \
                --region "${{ env.region }}"
              echo "Scaled Auto Scaling group '$asg_name' to min=0, max=0, desired=0."
            done

        # SCALE RDS
        - name: Get RDS Instances
          run: |
            instances=$(aws rds describe-db-instances --region "${{ env.region }}" \
              --query "DBInstances[?TagList[?Key=='scaling' && Value=='enabled'] && TagList[?Key=='environment' && Value=='${{ env.environment }}']].DBInstanceIdentifier" \
              --output text)
            echo "instances=$instances" >> $GITHUB_ENV

        - name: Scale RDS Up
          if: env.scaling_action == 'up'
          run: |
            timeout=300  # 5 minutes in seconds
            interval=15  # Check every 15 seconds

            # Loop through each instance and scale it up
            for instance in ${{ env.instances }}; do
              elapsed=0
              while [ $elapsed -lt $timeout ]; do
                current_state=$(aws rds describe-db-instances --region "${{ env.region }}" \
                  --db-instance-identifier "$instance" \
                  --query "DBInstances[0].DBInstanceStatus" --output text)

                if [ "$current_state" == "stopped" ]; then
                  echo "Starting RDS instance $instance in region ${{ env.region }}... 🟢"
                  aws rds start-db-instance --region "${{ env.region }}" --db-instance-identifier "$instance"
                  break

                elif [ "$current_state" == "available" ] || [ "$current_state" == "starting" ]; then
                  echo "RDS instance $instance is already in $current_state state."
                  break

                # Handling the case wherein a scale up is triggered immediately after a scale down
                else
                  echo "RDS instance $instance is in state $current_state. Continuing to wait..."
                fi

                sleep $interval
                elapsed=$((elapsed + interval))
              done

              if [ "$current_state" != "stopped" ] && [ "$current_state" != "available" ] && [ "$current_state" != "starting" ]; then
                curl -X POST -H 'Content-type: application/json' --data "{\"text\":\"An error occured while scaling $instance up as it is currently in the $current_state state\"}" ${{ secrets.DB_TESTING_SLACK_WEBHOOK }}
                echo "Could not initiate scale up since RDS instance $instance did not reach stopped state within the timeout period. Current state: $current_state"
              fi
            done

        - name: Scale RDS Down
          if: env.scaling_action == 'down'
          run: |
            timeout=300  # 5 minutes in seconds
            interval=15  # Check every 15 seconds

            # Loop through each instance and scale it up
            for instance in ${{ env.instances }}; do
              elapsed=0
              while [ $elapsed -lt $timeout ]; do
                current_state=$(aws rds describe-db-instances --region "${{ env.region }}" \
                  --db-instance-identifier "$instance" \
                  --query "DBInstances[0].DBInstanceStatus" --output text)

                if [ "$current_state" == "available" ]; then
                  echo "Stopping RDS instance $instance in region "${{ env.region }}"...🔴"
                  aws rds stop-db-instance --region "${{ env.region }}" --db-instance-identifier "$instance"
                  break

                elif [ "$current_state" == "stopped" ] || [ "$current_state" == "stopping" ]; then
                  echo "RDS instance $instance is already in $current_state state."
                  break

                # Handling the case wherein a scale down is triggered immediately after a scale up
                else
                  echo "RDS instance $instance is in state $current_state. Continuing to wait..."
                fi

                sleep $interval
                elapsed=$((elapsed + interval))
              done

              if [ "$current_state" != "available" ] && [ "$current_state" != "stopped" ] && [ "$current_state" != "stopping" ]; then
                echo "Could not initiate scale down since RDS instance $instance did not reach available state within the timeout period. Current state: $current_state"
                curl -X POST -H 'Content-type: application/json' --data "{\"text\":\"An error occured while scaling $instance down as it is currently in the $current_state state\"}" ${{ secrets.DB_TESTING_SLACK_WEBHOOK }}
              fi
            done

        - name: Slack Notification on Scaling Failure
          uses: slackapi/slack-github-action@v1.25.0
          if: failure()
          with:
            channel-id: C0232T0LP7V
            slack-message: "Something went wrong during the scaling activity ⚠️  ```${{ env.error_message }}```"
          env:
            SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_TOKEN }}
